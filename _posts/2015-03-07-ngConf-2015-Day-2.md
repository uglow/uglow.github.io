---
published: true
layout: post
title: "ngConf 2015 - Conference Day 2"
description: "ngConf 2015 - Conference Day 2"
modified: 2015-03-07
tags: [angularjs, ngConf, 2015]
comments: true
share: true 
image:
  feature: abstract-7.jpg
  credit: dargadgetz
  creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
---

**Updated @ 9am CST:**

##Keynote - Mi≈°ko Hevery & Rado Kirov (Google) - 9am

### Angular 2
- It is in the open. You can fork it, send PRs, etc.

#### Syntax
- Why are we changing it? It's about the semantics, not just a preference.
- Familiar vs simple - we tend to confuse these two things in our mind
- Av2 has simpler syntax rools, easier for tools to work with

#### Data Binding
- You could write a data-bound attribute as a literal, an expression, or an interpolation expression. This is confusing.
- Now there's only 2 kinds: literal or expression. Makes it easier for component user and component author
- Why [property] not {{expression}}?
  - Browser knows about 'real' attributes (like src="") and tries to use attribute.
  - This can be worked around with `ng-src` for certain components, but ultimately the problem is the browser knows the attribute's **key**
  - So by renaming the key, we can avoid the browser default behaviour. Hence `[attr]="expr"` is the new syntax
  - The proper way to handle this is to always bind to properties, not attributes.
  - We want to use Web Components in the future. They should work just like native component syntax
    - Properties, events and methods is the interface. We want to preserve this.
  - What about {{interpolation}}? Av2 will handle this for you, without the brackets.
- `<div [text]="exp"> <div [inner-html]="exp"> <div [hidden]="exp">` Av2 gets rid of a bunch of directives due to this new syntax.
- Tooling has trouble determining whether an expression is a statement, event or bindable-property.
  - `<component [select]="user.name(current)` = expression (also written as bind-select=""). No side effects.
  - `<component (select)="user.name(current)` = statement (also written as on-select=""). Side effects (assignment).
  - This allows most of the event directives to be removed e.g. `ng-blur`
- Reference Binding
  - Problem: How do you get a reference to an input field that is bound to a model property, so that you can focus it?
    - `<input #ref type=text> <div click="ref.focus()"`
  - Typos can be more easily detected now because component references are exposed.
- **Summary**: Property binding, event binding and reference binding

#### Micro-syntax
- Problem: `ng-repeat="item in items"`, what is `item in items`? It's complicated!
- Solution: Explicit templates.
  - `<template foreach #item [in]="items">`, this builds on existing syntax, but is quite wordy.
  - Short hand syntax: `<li template="foreach; #item; in=items"` compiles to above.
  - Better syntax: `<li *foreach="#item in items"` compiles to above.

Summary: Goal is to make syntax Predicatable, Simpler, Toolable.

Youtube Demo.

### Building the Demo
- Index.html, `<app>` tag instead of `ng-app`. Name is not special. It is a top-level component.
- Demo is in ES6, but you can write in ES5 too
- Component implementation declares it's tag selector as 'app'
- Transclusion replaced with shadowDOM content element
- Components/Directives declare the components/directives that they use. This means you no-longer have a global namespace of
  components, with the possibility of name collisions.
- *Ed Note*: Component definition and usage looks and feels more & more like Adobe Flex.
- This binding syntax effectively makes data-flow uni-directional, and a-cyclic. It's not possible to get into the situation
  where one binding property affects another and gets into an infinite loop.
- Components can emit events, and the component defines which events it will emit (like Flex)
- Following Web-Components style means that you can directly mix/use other web components inside Angular, such as Polymer components.
  **One syntax to use Angular components and Web Components**.
- But what about browsers that don't have ShadowDOM? **Av2 will emulate this for all the browsers, so it should still work**.








