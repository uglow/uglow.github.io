---
published: true
layout: post
title: "ngConf 2015 - Conference Day 2"
description: "ngConf 2015 - Conference Day 2"
modified: 2015-03-07
tags: [angularjs, ngConf, 2015]
comments: true
share: true 
image:
  feature: abstract-7.jpg
  credit: dargadgetz
  creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
---

**Updated @ 11am CST:**

## Large App Challenges - Jen Bourney (Google) - 11:05am

Works on Google Cloud Platform. Project has about 200K JS + template LOC
About 25MB of uncompressed code. Dozens of teams, multiple offices.


### Managing code size
- Having an SPA with 25MB of code is too large to download for a user. and not all of that code is used on every view
- Solution:
  - Divide code into modules
  - Lazy-load modules
  - Register a placeholder-route for each module
  - When module is loaded, register **real** routes, delete placeholder ones, call route.reload()
  - Example: /pizza, downloads module JS files, replaces /pizza with a bunch of additional routes
  
### Sharing code
- You need a plan to share code
- Benefits:
  - Consistency across site
  - Increases feature developer velocity
  - Keeps code size down
  - Can fix bugs in one place
  - UI libraries are key shareable things, as well as services
  
### Avoiding Conflicts
- Namespace collisions!
- Have a /common module, which is usable by other modules, but other modules cannot be shared with each other
- Pick a unique namespace: `namespace.Feature<Type>` E.g. `com.MyFeatureService`
- Avoid using $rootScope
- Encourage isolate scopes

### Global Changes
- Use a flag approach to turn on/off features
- Configurable components use a flag service to get the flags for that component, and then configure themselves.
- Upgrading Angular
  - Relied heavily on unit and integration tests
- Can adopt Angular if not using already
  - page-by-page conversion strategy
  
### Catching Errors
- Presubmit checks (lint, hooks)
- Compiler checks
- Running tests before submission
- CI server to run integration test
- Subtle failures:
  - missing directives
  - Solution: use screenshot comparison for directives
  
### Summary
- Create shared abstraction layers
- Watch JS download size
- Ensure thorough test coverage




## What's new in ngAnimate - Matias Niemelä (Google) - 10:45am

[Slides](http://slides.yearofmoo.com/ng-conf-2015/index.html)

### ngAnimate in 1.4
- Internal code is better, allows future extension, lots of bugs fixed
- More componentised
- $animate callbacks, allow you wait for a view to load in before doing something else
- $animateCSS:
  - replace need for Greensock, can do complex CSS animations in JavaScript. E.g. collapse animation on a panel, when the height is not known by CSS
- Anchoring
  - Ability to move an item from one view to another
  - Lots of stuff... can't keep up
  - Allows you to move components and see them move from one component into another (kind of like drag-and-drop)

### Future features
- Animation runners (players)
  - soon you will be able to pause, resume, skip animations
- Custom Drivers
- 1.5 and 2.0 code will be the same, just like the new router
- ngTimeline still being developed, will take time
  - Sequence events, run things in parallel
  - Reminds me of Flex animation declarative syntax



**Noticing a trend**: The services layer is being bypassed with components talking directly to data-model-implementations.
For example, FireBase, Falcor, Web Components. Now I don't know if this is because we are looking at demos, or whether 
this is deliberate. My basic concern is this: I don't want my business logic to be mixed with a specific data-fetching mechanism.

## TypeScript and Angular 2.0 - Jonathan Turner (Microsoft) - 10:20am

- Keeps stressing that everything is optional, use as little or as much as you want.
- Angular 2 works fine without it

### Status & Future
- Angular 2 building in TypeScript now
- Currently has lowest support for ES5 (version 1.4)
- TS 1.5 has much better ES6 support
- TS 1.5 Beta will be released in a few weeks
- TS 1.6 will add Generators and Async/Wait



## Binding to the Cloud with Falcor - Jafar Husain (NetFlix) - 9:55am

Every user wants to believe that the data they want is already on their device.

Does MVC *really* separate concerns? Netflix case study.

Basically saying that the controller needs to know what the view wants to present, so that it can ask for the right amount
of data. In reality, the controller and the view are normally coupled (e.g. a Web Component has a controller and a view).

### Falcor
- An async model for your app. A view requests data, Falcor gets it and async sends it back. The view decides how much
  data it wants.
- Falcor caches the data.
- It implements model as a JSON object, where addressing the data is like `person.movie.related`
- Ed Note: Feels similar to FireBase, but a little different
- Controller is responsible for choosing the root node in the object graph, view decides what to show
- Angular v2 will allow you to bind to asynchronous models / promises / observables
- You don't need to create all these little services that return a subset of the data model anymore. Now you  address the 
  data that you want directly. Means that your caching is always in sync too.
- Allows you to work with the data whether it is local or remote.

NetFlix is using Falcor today in production. Falcor will become **open-source** soon.



##Keynote - Miško Hevery & Rado Kirov (Google) - 9am

### Angular 2
- It is in the open. You can fork it, send PRs, etc.

#### Syntax
- Why are we changing it? It's about the semantics, not just a preference.
- Familiar vs simple - we tend to confuse these two things in our mind
- Av2 has simpler syntax rools, easier for tools to work with

#### Data Binding
- You could write a data-bound attribute as a literal, an expression, or an interpolation expression. This is confusing.
- Now there's only 2 kinds: literal or expression. Makes it easier for component user and component author
- Why [property] not {{expression}}?
  - Browser knows about 'real' attributes (like src="") and tries to use attribute.
  - This can be worked around with `ng-src` for certain components, but ultimately the problem is the browser knows the attribute's **key**
  - So by renaming the key, we can avoid the browser default behaviour. Hence `[attr]="expr"` is the new syntax
  - The proper way to handle this is to always bind to properties, not attributes.
  - We want to use Web Components in the future. They should work just like native component syntax
    - Properties, events and methods is the interface. We want to preserve this.
  - What about {{interpolation}}? Av2 will handle this for you, without the brackets.
- `<div [text]="exp"> <div [inner-html]="exp"> <div [hidden]="exp">` Av2 gets rid of a bunch of directives due to this new syntax.
- Tooling has trouble determining whether an expression is a statement, event or bindable-property.
  - `<component [select]="user.name(current)` = expression (also written as bind-select=""). No side effects.
  - `<component (select)="user.name(current)` = statement (also written as on-select=""). Side effects (assignment).
  - This allows most of the event directives to be removed e.g. `ng-blur`
- Reference Binding
  - Problem: How do you get a reference to an input field that is bound to a model property, so that you can focus it?
    - `<input #ref type=text> <div click="ref.focus()"`
  - Typos can be more easily detected now because component references are exposed.
- **Summary**: Property binding, event binding and reference binding

#### Micro-syntax
- Problem: `ng-repeat="item in items"`, what is `item in items`? It's complicated!
- Solution: Explicit templates.
  - `<template foreach #item [in]="items">`, this builds on existing syntax, but is quite wordy.
  - Short hand syntax: `<li template="foreach; #item; in=items"` compiles to above.
  - Better syntax: `<li *foreach="#item in items"` compiles to above.

Summary: Goal is to make syntax Predicatable, Simpler, Toolable.

Youtube Demo.

### Building the Demo
- Index.html, `<app>` tag instead of `ng-app`. Name is not special. It is a top-level component.
- Demo is in ES6, but you can write in ES5 too
- Component implementation declares it's tag selector as 'app'
- Transclusion replaced with shadowDOM content element
- Components/Directives declare the components/directives that they use. This means you no-longer have a global namespace of
  components, with the possibility of name collisions.
- *Ed Note*: Component definition and usage looks and feels more & more like Adobe Flex.
- This binding syntax effectively makes data-flow uni-directional, and a-cyclic. It's not possible to get into the situation
  where one binding property affects another and gets into an infinite loop.
- Components can emit events, and the component defines which events it will emit (like Flex)
- Following Web-Components style means that you can directly mix/use other web components inside Angular, such as Polymer components.
  **One syntax to use Angular components and Web Components**.
- But what about browsers that don't have ShadowDOM? **Av2 will emulate this for all the browsers, so it should still work**.








